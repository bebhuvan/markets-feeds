---
import Layout from '../layouts/Layout.astro';
import Navigation from '../components/Navigation.astro';
import CategoryHeader from '../components/CategoryHeader.astro';
import LinkCard from '../components/LinkCard.astro';
import type { FeedItem } from '../types';
import '../styles/global.css';

// Load recent link data with error handling
let linkFiles: any[] = [];
let allLinks: FeedItem[] = [];

try {
  linkFiles = await Astro.glob('../content/links/*.json');
  
  // Sort files by date from content (Astro.glob url property is unreliable)
  const sortedFiles = linkFiles
    .filter(file => Array.isArray(file.default) && file.default.length > 0)
    .filter(file => {
      // Skip sample data by checking first item properties
      const firstItem = file.default[0];
      return firstItem && !firstItem.id?.includes('sample');
    })
    .sort((a, b) => {
      // Sort by newest first item date
      const dateA = a.default[0]?.publishedAt || '2000-01-01';
      const dateB = b.default[0]?.publishedAt || '2000-01-01';
      return new Date(dateB).getTime() - new Date(dateA).getTime();
    });

  // Load the latest 10 files to ensure we get blog content
  const recentFiles = sortedFiles.slice(0, 10);

  for (const file of recentFiles) {
    try {
      if (Array.isArray(file.default)) {
        const blogItems = file.default.filter((item: FeedItem) => 
          item && item.category === 'blogs' && item.title && item.url
        );
        allLinks.push(...blogItems);
      }
    } catch (fileError) {
      console.error(`Error processing file:`, fileError);
    }
  }
} catch (error) {
  console.error('Error loading link files:', error);
}

// Sort by published date
allLinks.sort((a, b) => new Date(b.publishedAt).getTime() - new Date(a.publishedAt).getTime());

// Pagination logic
const ARTICLES_PER_PAGE = 20;
const currentPage = parseInt(Astro.url.searchParams.get('page') || '1');
const totalPages = Math.ceil(allLinks.length / ARTICLES_PER_PAGE);
const startIndex = (currentPage - 1) * ARTICLES_PER_PAGE;
const endIndex = startIndex + ARTICLES_PER_PAGE;
const displayedLinks = allLinks.slice(startIndex, endIndex);

// Pagination info
const showingStart = startIndex + 1;
const showingEnd = Math.min(endIndex, allLinks.length);
const hasPrevPage = currentPage > 1;
const hasNextPage = currentPage < totalPages;

---

<Layout title="Blogs & Opinion - Markets Feeds" description="Latest financial blogs, opinion pieces, and editorial content">
  
  <div class="container max-w-4xl mx-auto px-4 sm:px-6 lg:px-8 py-6 lg:py-12 overflow-x-hidden">
    <CategoryHeader title="Blogs & Opinion" currentPage="blogs" />
    
    <Navigation currentPage="blogs" />
    
    <main id="linkStream">
      {displayedLinks.length > 0 ? (
        <div>
          <!-- Show pagination info -->
          <div class="flex justify-between items-center mb-6 text-sm text-text-subtle">
            <div>Showing {showingStart}-{showingEnd} of {allLinks.length} blog posts</div>
            <div>Page {currentPage} of {totalPages}</div>
          </div>
          
          {displayedLinks.map((link) => (
            <LinkCard link={link} />
          ))}
          
          <!-- Pagination controls -->
          {totalPages > 1 && (
            <div class="flex justify-center items-center gap-4 mt-8 pt-6 border-t border-border">
              {hasPrevPage && (
                <a 
                  href={`/blogs?page=${currentPage - 1}`}
                  class="btn-secondary flex items-center gap-2 px-4 py-2"
                >
                  ← Previous
                </a>
              )}
              
              <span class="px-4 py-2 text-sm text-text-subtle">
                Page {currentPage} of {totalPages}
              </span>
              
              {hasNextPage && (
                <a 
                  href={`/blogs?page=${currentPage + 1}`}
                  class="btn-secondary flex items-center gap-2 px-4 py-2"
                >
                  Next →
                </a>
              )}
            </div>
          )}
        </div>
      ) : (
        <div class="py-12 text-center text-text-subtle">
          <p class="mb-4">No blog posts available</p>
          <p class="text-sm">Blog content is being aggregated. Check back soon!</p>
        </div>
      )}
    </main>
    
    <div id="emptyState" class="hidden py-12 text-center text-text-subtle">
      <p>No results found</p>
    </div>
  </div>
  
  
  <script>
    // Search functionality
    const searchInput = document.getElementById('searchInput') as HTMLInputElement;
    const linkItems = document.querySelectorAll('.link-item');
    const emptyState = document.getElementById('emptyState');
    const linkStream = document.getElementById('linkStream');
    
    let searchTerm = '';
    
    if (searchInput) {
      searchInput.addEventListener('input', () => {
        searchTerm = searchInput.value.toLowerCase();
        applyFilters();
      });
    }
    
    function applyFilters() {
      let visibleCount = 0;
      
      linkItems.forEach(item => {
        const title = item.querySelector('h2')?.textContent?.toLowerCase() || '';
        const summary = item.querySelector('p')?.textContent?.toLowerCase() || '';
        const tags = item.getAttribute('data-tags')?.toLowerCase() || '';
        
        const matchesSearch = searchTerm === '' || 
          title.includes(searchTerm) || 
          summary.includes(searchTerm) ||
          tags.includes(searchTerm);
        
        if (matchesSearch) {
          (item as HTMLElement).style.display = 'block';
          visibleCount++;
        } else {
          (item as HTMLElement).style.display = 'none';
        }
      });
      
      // Show/hide empty state
      if (visibleCount === 0) {
        linkStream?.classList.add('hidden');
        emptyState?.classList.remove('hidden');
      } else {
        linkStream?.classList.remove('hidden');
        emptyState?.classList.add('hidden');
      }
    }
    
    // Global function for tag clicking
    (window as any).filterByTag = function(tag: string) {
      if (searchInput) {
        searchInput.value = tag.toLowerCase();
        searchTerm = tag.toLowerCase();
        applyFilters();
        searchInput.focus();
      }
    };
  </script>
</Layout>